# Creational patterns

# Structural patterns

# Behavioral Patterns

## State
### 适用性
- 如果一个对象的行为取决于它 的状态，并且它必须在运行时根据状态改变行为那么可以使用状态模式.
- 一个操作中含有庞大的多分支条件语句， 且这些分支依赖于该对象的状态. 这个状态通>常用一个或多个枚举表示. 通常有多个操作包含此相同的条件结构. State模式就是将每一>个条件分支放入一个独立的类中. 这使得你可以根据对象自身的情况，将对象的状态也作为
一个对象， 切这一状态对象可以不依赖于其他对象而独立变化.

### 效果
- 它将与特定状态相关的行为局部化， 并且将不同状态的行为分割开来.

State 模式将所有与一个特定状态的相关行为都放到一个对象中.
因为所有与状态相关的代码都在某个State的子类中, 因此通过定义新的子类可以很容易的增加新的状态和转换.

当然也可以定义一些枚举值来作为内部状态. 在状态切换时可以显示检查和修改这些状态值. 于是代码中可能会有`很多的if或者case`， 另外`添加一个新的状态可能需要更改若干个操作`，这使得`维护变得复杂`了。

State模式避免了这个问题, 不过也引入了新的问题, State模式将不同状态的行为分布在了多个State子类中, 因此子类的数目增加了, 相对于单个类的实现来说不够紧凑.

无论是`很长的函数`或者`巨大的条件语句`都是不受欢迎的.
他们使得代码不够清晰, 且难以修改和扩展.
State模式将这些if/switch语句分布到了多个State子类中.

- 

